import { FC, ReactNode } from 'react';

type DefaultProps = { children?: ReactNode | undefined };

type InjectableHook<$V extends object> = {
  subscribe: (callback: (data: $V) => void) => () => void;
  once: (callback: (data: $V) => void) => void;
};

type Unit = {
  HOOK_INJECTOR: 'HOOK_INJECTOR';
  CONSTANT_INJECTOR: 'CONSTANT_INJECTOR';
};

type ConstantDependency<$D, $K> = {
  require: $D;
  key: $K;
  unit: Unit['CONSTANT_INJECTOR'];
};

type ComponentDependency<$P, $D> = InjectableComponentResolver<$P, $D>;

type HookDependency<$D, $K> = {
  require: $D;
  key: $K;
  unit: Unit['HOOK_INJECTOR'];
};

type AnyConstantDependency = ConstantDependency<any, any>;

type PossibleConstantDependency = AnyConstantDependency;

type AnyHookDependency = HookDependency<any, any>;

type PossibleHookDependency = AnyHookDependency | AnyConstantDependency;

type AnyComponentDependency = ComponentDependency<any, any>;

type PossibleComponentDependency = AnyHookDependency | AnyConstantDependency | AnyComponentDependency;

type UseConstantDependency<$D extends PossibleConstantDependency> = $D extends {
  require: infer I_$D;
  unit: Unit['CONSTANT_INJECTOR'];
}
  ? I_$D
  : never;

type UseHookDependency<$D extends PossibleHookDependency> = $D extends {
  require: infer I_$D;
  unit: Unit['HOOK_INJECTOR'];
}
  ? () => I_$D
  : $D extends { require: infer I_$D; unit: Unit['CONSTANT_INJECTOR'] }
  ? I_$D
  : never;

type UseComponentDependency<$D extends PossibleComponentDependency> = $D extends {
  require: infer I_$D;
  unit: Unit['HOOK_INJECTOR'];
}
  ? () => I_$D
  : $D extends { require: infer I_$D; unit: Unit['CONSTANT_INJECTOR'] }
  ? I_$D
  : $D extends (dependencies: any) => (props: infer I_$P) => JSX.Element
  ? (props: I_$P) => JSX.Element
  : never;

type InjectedConstantDependency<$D extends AnyConstantDependency> = $D extends {
  require: infer I_$D;
  key: infer I_$K;
  unit: Unit['CONSTANT_INJECTOR'];
}
  ? { [key in I_$K]: I_$D }
  : never;

type InjectedHookDependency<$D extends PossibleHookDependency> = $D extends {
  require: infer I_$D;
  key: infer I_$K;
  unit: Unit['HOOK_INJECTOR'];
}
  ? { [key in I_$K]: InjectableHook<I_$D> }
  : $D extends {
      require: infer I_$D;
      key: infer I_$K;
      unit: Unit['CONSTANT_INJECTOR'];
    }
  ? { [key in I_$K]: I_$D }
  : never;

type InjectedComponentDependency<$D extends PossibleComponentDependency> = $D extends {
  require: infer I_$D;
  key: infer I_$K;
  unit: Unit['HOOK_INJECTOR'];
}
  ? { [key in I_$K]: InjectableHook<I_$D> }
  : $D extends {
      require: infer I_$D;
      key: infer I_$K;
      unit: Unit['CONSTANT_INJECTOR'];
    }
  ? { [key in I_$K]: I_$D }
  : $D extends (dep: infer I_$D) => (props: any) => JSX.Element
  ? I_$D
  : never;

type InjectableConstantResolver<$V, $D> = $D extends void ? () => $V : (dependencies: $D) => $V;

type InjectableHookResolver<$V extends object, $D> = $D extends void ? () => InjectableHook<$V> : (dependencies: $D) => InjectableHook<$V>;

type InjectableComponentResolver<$P, $D> = $D extends void ? () => FC<$P> : (dependencies: $D) => FC<$P>;

interface InjectableConstantResolverFactory {
  <$V>(project: () => $V): InjectableConstantResolver<$V, void>;
  <$V, A extends PossibleConstantDependency>(a: A, project: (pa: UseConstantDependency<A>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency>(a: A, b: B, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency>(a: A, b: B, c: C, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency, K extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>, pk: UseConstantDependency<K>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J> & InjectedConstantDependency<K>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency, K extends PossibleConstantDependency, L extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>, pk: UseConstantDependency<K>, pl: UseConstantDependency<L>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J> & InjectedConstantDependency<K> & InjectedConstantDependency<L>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency, K extends PossibleConstantDependency, L extends PossibleConstantDependency, M extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>, pk: UseConstantDependency<K>, pl: UseConstantDependency<L>, pm: UseConstantDependency<M>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J> & InjectedConstantDependency<K> & InjectedConstantDependency<L> & InjectedConstantDependency<M>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency, K extends PossibleConstantDependency, L extends PossibleConstantDependency, M extends PossibleConstantDependency, N extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>, pk: UseConstantDependency<K>, pl: UseConstantDependency<L>, pm: UseConstantDependency<M>, pn: UseConstantDependency<N>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J> & InjectedConstantDependency<K> & InjectedConstantDependency<L> & InjectedConstantDependency<M> & InjectedConstantDependency<N>>;
  <$V, A extends PossibleConstantDependency, B extends PossibleConstantDependency, C extends PossibleConstantDependency, D extends PossibleConstantDependency, E extends PossibleConstantDependency, F extends PossibleConstantDependency, G extends PossibleConstantDependency, H extends PossibleConstantDependency, I extends PossibleConstantDependency, J extends PossibleConstantDependency, K extends PossibleConstantDependency, L extends PossibleConstantDependency, M extends PossibleConstantDependency, N extends PossibleConstantDependency, O extends PossibleConstantDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, project: (pa: UseConstantDependency<A>, pb: UseConstantDependency<B>, pc: UseConstantDependency<C>, pd: UseConstantDependency<D>, pe: UseConstantDependency<E>, pf: UseConstantDependency<F>, pg: UseConstantDependency<G>, ph: UseConstantDependency<H>, pi: UseConstantDependency<I>, pj: UseConstantDependency<J>, pk: UseConstantDependency<K>, pl: UseConstantDependency<L>, pm: UseConstantDependency<M>, pn: UseConstantDependency<N>, po: UseConstantDependency<O>) => $V): InjectableConstantResolver<$V, InjectedConstantDependency<A> & InjectedConstantDependency<B> & InjectedConstantDependency<C> & InjectedConstantDependency<D> & InjectedConstantDependency<E> & InjectedConstantDependency<F> & InjectedConstantDependency<G> & InjectedConstantDependency<H> & InjectedConstantDependency<I> & InjectedConstantDependency<J> & InjectedConstantDependency<K> & InjectedConstantDependency<L> & InjectedConstantDependency<M> & InjectedConstantDependency<N> & InjectedConstantDependency<O>>;
}

interface InjectableHookResolverFactory {
  <$V extends object>(project: () => $V): InjectableHookResolver<$V, void>;
  <$V extends object, A extends PossibleHookDependency>(a: A, project: (pa: UseHookDependency<A>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency>(a: A, b: B, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency>(a: A, b: B, c: C, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency>(a: A, b: B, c: C, d: D, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency, K extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>, pk: UseHookDependency<K>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J> & InjectedHookDependency<K>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency, K extends PossibleHookDependency, L extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>, pk: UseHookDependency<K>, pl: UseHookDependency<L>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J> & InjectedHookDependency<K> & InjectedHookDependency<L>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency, K extends PossibleHookDependency, L extends PossibleHookDependency, M extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>, pk: UseHookDependency<K>, pl: UseHookDependency<L>, pm: UseHookDependency<M>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J> & InjectedHookDependency<K> & InjectedHookDependency<L> & InjectedHookDependency<M>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency, K extends PossibleHookDependency, L extends PossibleHookDependency, M extends PossibleHookDependency, N extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>, pk: UseHookDependency<K>, pl: UseHookDependency<L>, pm: UseHookDependency<M>, pn: UseHookDependency<N>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J> & InjectedHookDependency<K> & InjectedHookDependency<L> & InjectedHookDependency<M> & InjectedHookDependency<N>>;
  <$V extends object, A extends PossibleHookDependency, B extends PossibleHookDependency, C extends PossibleHookDependency, D extends PossibleHookDependency, E extends PossibleHookDependency, F extends PossibleHookDependency, G extends PossibleHookDependency, H extends PossibleHookDependency, I extends PossibleHookDependency, J extends PossibleHookDependency, K extends PossibleHookDependency, L extends PossibleHookDependency, M extends PossibleHookDependency, N extends PossibleHookDependency, O extends PossibleHookDependency>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, project: (pa: UseHookDependency<A>, pb: UseHookDependency<B>, pc: UseHookDependency<C>, pd: UseHookDependency<D>, pe: UseHookDependency<E>, pf: UseHookDependency<F>, pg: UseHookDependency<G>, ph: UseHookDependency<H>, pi: UseHookDependency<I>, pj: UseHookDependency<J>, pk: UseHookDependency<K>, pl: UseHookDependency<L>, pm: UseHookDependency<M>, pn: UseHookDependency<N>, po: UseHookDependency<O>) => $V): InjectableHookResolver<$V, InjectedHookDependency<A> & InjectedHookDependency<B> & InjectedHookDependency<C> & InjectedHookDependency<D> & InjectedHookDependency<E> & InjectedHookDependency<F> & InjectedHookDependency<G> & InjectedHookDependency<H> & InjectedHookDependency<I> & InjectedHookDependency<J> & InjectedHookDependency<K> & InjectedHookDependency<L> & InjectedHookDependency<M> & InjectedHookDependency<N> & InjectedHookDependency<O>>;
}

interface InjectableComponentResolverFactory {
  <$P = DefaultProps>(project: () => FC<$P>): InjectableComponentResolver<$P, void>;
  <A extends PossibleComponentDependency, $P = DefaultProps>(a: A, project: (pa: UseComponentDependency<A>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, K extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>, pk: UseComponentDependency<K>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J> & InjectedComponentDependency<K>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, K extends PossibleComponentDependency, L extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>, pk: UseComponentDependency<K>, pl: UseComponentDependency<L>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J> & InjectedComponentDependency<K> & InjectedComponentDependency<L>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, K extends PossibleComponentDependency, L extends PossibleComponentDependency, M extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>, pk: UseComponentDependency<K>, pl: UseComponentDependency<L>, pm: UseComponentDependency<M>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J> & InjectedComponentDependency<K> & InjectedComponentDependency<L> & InjectedComponentDependency<M>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, K extends PossibleComponentDependency, L extends PossibleComponentDependency, M extends PossibleComponentDependency, N extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>, pk: UseComponentDependency<K>, pl: UseComponentDependency<L>, pm: UseComponentDependency<M>, pn: UseComponentDependency<N>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J> & InjectedComponentDependency<K> & InjectedComponentDependency<L> & InjectedComponentDependency<M> & InjectedComponentDependency<N>>;
  <A extends PossibleComponentDependency, B extends PossibleComponentDependency, C extends PossibleComponentDependency, D extends PossibleComponentDependency, E extends PossibleComponentDependency, F extends PossibleComponentDependency, G extends PossibleComponentDependency, H extends PossibleComponentDependency, I extends PossibleComponentDependency, J extends PossibleComponentDependency, K extends PossibleComponentDependency, L extends PossibleComponentDependency, M extends PossibleComponentDependency, N extends PossibleComponentDependency, O extends PossibleComponentDependency, $P = DefaultProps>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, project: (pa: UseComponentDependency<A>, pb: UseComponentDependency<B>, pc: UseComponentDependency<C>, pd: UseComponentDependency<D>, pe: UseComponentDependency<E>, pf: UseComponentDependency<F>, pg: UseComponentDependency<G>, ph: UseComponentDependency<H>, pi: UseComponentDependency<I>, pj: UseComponentDependency<J>, pk: UseComponentDependency<K>, pl: UseComponentDependency<L>, pm: UseComponentDependency<M>, pn: UseComponentDependency<N>, po: UseComponentDependency<O>) => FC<$P>): InjectableComponentResolver<$P, InjectedComponentDependency<A> & InjectedComponentDependency<B> & InjectedComponentDependency<C> & InjectedComponentDependency<D> & InjectedComponentDependency<E> & InjectedComponentDependency<F> & InjectedComponentDependency<G> & InjectedComponentDependency<H> & InjectedComponentDependency<I> & InjectedComponentDependency<J> & InjectedComponentDependency<K> & InjectedComponentDependency<L> & InjectedComponentDependency<M> & InjectedComponentDependency<N> & InjectedComponentDependency<O>>;
}

interface ConstantInjector {
  <$V>(): $V extends infer I_$V ? <$K extends string>(key: $K) => $K extends infer I_$K ? ConstantDependency<I_$V, I_$K> : never : never;
}

interface HookInjector {
  <$V>(): $V extends infer I_$V ? <$K extends string>(key: $K) => $K extends infer I_$K ? HookDependency<I_$V, I_$K> : never : never;
}

interface Configure {
  constant: InjectableConstantResolverFactory;
  hook: InjectableHookResolverFactory;
  component: InjectableComponentResolverFactory;
  InjectableHooksHolder: FC;
  inject: {
    constant: ConstantInjector;
    hook: HookInjector;
  };
}

interface UseAction {
  <T extends Function>(callback: T): T;
}

export const configure: () => Configure;
export const useAction: UseAction;
